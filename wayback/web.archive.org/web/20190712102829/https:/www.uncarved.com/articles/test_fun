<!DOCTYPE html
PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
    <!-- turn this into html5 -->
    <head><script src="//archive.org/includes/analytics.js?v=cf34f82" type="text/javascript"></script>
<script type="text/javascript">window.addEventListener('DOMContentLoaded',function(){var v=archive_analytics.values;v.service='wb';v.server_name='wwwb-app39.us.archive.org';v.server_ms=218;archive_analytics.send_pageview({});});</script><script type="text/javascript" src="/_static/js/playback.bundle.js?v=R56vIgLu" charset="utf-8"></script>
<script type="text/javascript" src="/_static/js/wombat.js?v=cRqOKCOw" charset="utf-8"></script>
<script type="text/javascript">
if (window._WBWombatInit) {
  wbinfo = {}
  wbinfo.url = "http://www.uncarved.com/articles/test_fun";
  wbinfo.timestamp = "20160512181905";
  wbinfo.request_ts = "20160512181905";
  wbinfo.prefix = "https://web.archive.org/web/";
  wbinfo.mod = "if_";
  wbinfo.is_framed = false;
  wbinfo.is_live = false;
  wbinfo.coll = "web";
  wbinfo.proxy_magic = "";
  wbinfo.static_prefix = "/_static/";
  wbinfo.enable_auto_fetch = true;
  wbinfo.auto_fetch_worker_prefix = "https://web.archive.org/web/";
  wbinfo.wombat_ts = "20160512181905";
  wbinfo.wombat_sec = "1463077145";
  wbinfo.wombat_scheme = "https";
  wbinfo.wombat_host = "www.uncarved.com";
  wbinfo.ignore_prefixes = ["/__wb/",
                            "/_static/",
                            "/web/",
                            "http://analytics.archive.org/",
                            "https://analytics.archive.org/",
                            "//analytics.archive.org/",
                            "http://archive.org/",
                            "https://archive.org/",
                            "//archive.org/",
                            "http://faq.web.archive.org/",
                            "http://web.archive.org/",
                            "https://web.archive.org/"
                            ];
  wbinfo.wombat_opts = {};
  window._WBWombatInit(wbinfo);
}
__wm.init("https://web.archive.org/web");
</script>
<link rel="stylesheet" type="text/css" href="/_static/css/banner-styles.css?v=_99BHQfY" />
<link rel="stylesheet" type="text/css" href="/_static/css/iconochive.css?v=qtvMKcIJ" />
<!-- End Wayback Rewrite JS Include -->

        <meta http-equiv="content-type" content="text/html;charset=utf-8"/>
        <meta name="Author" content="Sean Hunter"/>
        <meta name="MSSmartTagsPreventParsing" content="TRUE"/>
        <meta name="description" content="Using monads to thread state, we make a purely functional version of the test harness - <p>To paraphrase Crocodile Dundee, this isn't a monad tutorial <..."/>
		<link rel="stylesheet" type="text/css" href="/web/20160512181905cs_/http://www.uncarved.com/static/style.css"/>
        <link rel="self" type="text/html" href="http://www.uncarved.com/articles/test_fun"/>
        <title>The Uncarved Blog: A Functional Test Harness</title>
	</head>

	<body>
		<div id="left_menu">
			<ul>
                <li><a href="https://web.archive.org/web/20160512181905/http://www.uncarved.com/articles/test_fun">permalink</a></li>
                <li><a href="https://web.archive.org/web/20160512181905/http://www.uncarved.com/">top</a></li>
                
				<li><a href="/web/20160512181905/http://www.uncarved.com/articles/contact">contact me</a></li>
				<li><a href="/web/20160512181905/http://www.uncarved.com/login/" rel="nofollow">not logged in</a></li>
                
			</ul>
		</div>
		<div class="body">
            
			<h2>
                
                A Functional Test Harness
			</h2>
            

            
            <div class="precis">Using monads to thread state, we make a purely functional version of the test harness</div>
            

            <p>To paraphrase Crocodile Dundee, this isn't a monad tutorial <a href="https://web.archive.org/web/20160512181905/http://enfranchisedmind.com/blog/2007/08/06/a-monad-tutorial-for-ocaml/">this</a> is a monad tutorial.  However, I decided to do something that would help me to understand monads, and that is to use them in a practical way.  </p>
<p>The <a href="https://web.archive.org/web/20160512181905/http://www.uncarved.com/blog/testing_ocaml.mrk">object-oriented test framework</a> we developed doesn't feel very idiomatic and as I learn
more about FP, and it feels as if we could do something a lot nicer.  So I set
about thinking so how to make a purely functional test framework.  The first
thing that strikes you is how useful state is.  In a purely functional
framework we have to thread that state through our functions, and one elegant
way to do that is through monads.</p>
<p>Now if you read the monad tutorial, you will realise that a monad is a magic
box and all you can really do with a monad is put something in the box, or
apply a function which will return another magic box.  This is all very well,
but its not great at explaining how (in a practical sense) anything actually
gets done.</p>
<p>We start with what it's going to look like when you actually use the functional
test api:</p>
<pre><code>Test.test_begin &gt;&gt;=
Test.ok "Something which should be true" true_thing &gt;&gt;=
Test.not_ok "Something which should not be false" false_thing &gt;&gt;=
Test.fail_if "This should raise an exception" (fun () -&gt; raise (Failure "aiee")) &gt;&gt;=
Test.test_end
</code></pre>
<p>The &gt;&gt;= is borrowed from Haskell, and is the "bind" operator, which acts as the
glue here, sending the state from one function to the next.  So our first function (test_begin) needs to create the monad and
bung in the starting state.  The rest of the functions accept as their last
argument the current state in its native form and return the updated state in the State monad.  This means that after
the arguments that you see above have been applied, they are candidates for the
"bind" function.</p>
<p>So without further ado, our monad:</p>
<pre><code>(** The basic type sig of a monad *)
module type MONAD = sig
    type 'a t
    val return : 'a -&gt; 'a t
    val bind : 'a t -&gt; ('a -&gt; 'b t) -&gt; 'b t
end

(** our state monad which will bind all our tests together *)
module State : MONAD = struct
    type 'a t = 'a
    let return x = x
    let bind m f = f m
end
</code></pre>
<p>It would be pretty hard to make anything simpler than that, but it fulfills the requirements to be a monad and it turns out a little goes a long way.  Here's our functional test module:</p>
<pre><code>module Test = struct
    (** the actual state which gets threaded through each fn *)
    type test_state = {n:int; ok:int}

    (** helper fns which return the state when it has succeeded or failed *)
    let succeeded s = State.return {n=s.n+1; ok=s.ok+1}
    let failed s = State.return {n=s.n+1; ok=s.ok}

    (** Pass the initial state into the State monad *)
    let test_begin = State.return {n=0; ok=0}

    (** we use this func tos implement all the rest.  It takes a string and a
    predicate, and the state, then succeeds if the predicate returns true. *)
    let pass_if desc pred s =
    let dots = String.make (50-(min 50 (String.length desc))) '.' in
    Printf.printf "%5.5d: %s ....%s" s.n desc dots;
    try
        if pred () then
        begin
            Printf.printf "ok\n" ;
            succeeded s
        end
        else
        begin
            Printf.printf "not ok\n";
            failed s
        end
    with
        _ -&gt;Printf.printf "not ok (threw exception)\n";
        failed s

    (** Runs a predicate function and fails if it throws or
     returns true.  Otherwise it succeeds *)
    let fail_if desc pred s = pass_if desc (fun () -&gt; not pred) s


    (** Takes a bool and marks the test as succeeded if it is true *)
    let ok desc x s = pass_if desc (fun () -&gt; x) s

    (** Takes a bool and marks the test as failed if it is true *)
    let not_ok desc x s = ok desc (not x) s

    let test_end s =
    Printf.printf "End tests: %d of %d tests passed\n" s.ok s.n ;
    State.return s
end
</code></pre>
<p>Nifty, no? You'll notice that the functions are all very similar to those in the OO version, except that their final argument is a state record, and instead of updating member data in the object, they simply update this state record and use "State.return" to pass it into the State monad. To make the initial code snippet work, the only thing that remains is:</p>
<pre><code>let ( &gt;&gt;= ) = State.bind
</code></pre>
		<hr/>
        <p class="footer">
        
        <span id="tags">Tags:
            
            <a href="https://web.archive.org/web/20160512181905/http://www.uncarved.com/tags/computers">computers</a>
            
        </span>
        
        Last modified: 2008-06-16T07:29:20Z</p>
        <p class="tagline">Unless otherwise specified the contents of this page are copyright &copy; 2015 <a href="https://web.archive.org/web/20160512181905/mailto:sean@uncarved.com">Sean Hunter</a>.  This work is licensed under a Creative Commons Attribution-ShareAlike 4.0 International <a rel="license" href="https://web.archive.org/web/20160512181905/http://creativecommons.org/licenses/by-sa/4.0/">License</a>.
        <!-- figure out metadata -->
	</p>
		</div>
    </body>
</html><!--
     FILE ARCHIVED ON 18:19:05 May 12, 2016 AND RETRIEVED FROM THE
     INTERNET ARCHIVE ON 06:58:42 Jul 30, 2020.
     JAVASCRIPT APPENDED BY WAYBACK MACHINE, COPYRIGHT INTERNET ARCHIVE.

     ALL OTHER CONTENT MAY ALSO BE PROTECTED BY COPYRIGHT (17 U.S.C.
     SECTION 108(a)(3)).
-->
<!--
playback timings (ms):
  esindex: 0.016
  LoadShardBlock: 90.743 (3)
  exclusion.robots.policy: 0.179
  captures_list: 114.41
  exclusion.robots: 0.199
  PetaboxLoader3.resolve: 60.966
  load_resource: 96.134
  PetaboxLoader3.datanode: 79.649 (4)
  RedisCDXSource: 1.594
  CDXLines.iter: 18.515 (3)
-->