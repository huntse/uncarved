<!DOCTYPE html
PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
    <!-- turn this into html5 -->
    <head><script src="//archive.org/includes/analytics.js?v=cf34f82" type="text/javascript"></script>
<script type="text/javascript">window.addEventListener('DOMContentLoaded',function(){var v=archive_analytics.values;v.service='wb';v.server_name='wwwb-app39.us.archive.org';v.server_ms=177;archive_analytics.send_pageview({});});</script><script type="text/javascript" src="/_static/js/playback.bundle.js?v=R56vIgLu" charset="utf-8"></script>
<script type="text/javascript" src="/_static/js/wombat.js?v=cRqOKCOw" charset="utf-8"></script>
<script type="text/javascript">
if (window._WBWombatInit) {
  wbinfo = {}
  wbinfo.url = "http://www.uncarved.com/articles/practical_ocaml";
  wbinfo.timestamp = "20160512184058";
  wbinfo.request_ts = "20160512184058";
  wbinfo.prefix = "https://web.archive.org/web/";
  wbinfo.mod = "if_";
  wbinfo.is_framed = false;
  wbinfo.is_live = false;
  wbinfo.coll = "web";
  wbinfo.proxy_magic = "";
  wbinfo.static_prefix = "/_static/";
  wbinfo.enable_auto_fetch = true;
  wbinfo.auto_fetch_worker_prefix = "https://web.archive.org/web/";
  wbinfo.wombat_ts = "20160512184058";
  wbinfo.wombat_sec = "1463078458";
  wbinfo.wombat_scheme = "https";
  wbinfo.wombat_host = "www.uncarved.com";
  wbinfo.ignore_prefixes = ["/__wb/",
                            "/_static/",
                            "/web/",
                            "http://analytics.archive.org/",
                            "https://analytics.archive.org/",
                            "//analytics.archive.org/",
                            "http://archive.org/",
                            "https://archive.org/",
                            "//archive.org/",
                            "http://faq.web.archive.org/",
                            "http://web.archive.org/",
                            "https://web.archive.org/"
                            ];
  wbinfo.wombat_opts = {};
  window._WBWombatInit(wbinfo);
}
__wm.init("https://web.archive.org/web");
</script>
<link rel="stylesheet" type="text/css" href="/_static/css/banner-styles.css?v=_99BHQfY" />
<link rel="stylesheet" type="text/css" href="/_static/css/iconochive.css?v=qtvMKcIJ" />
<!-- End Wayback Rewrite JS Include -->

        <meta http-equiv="content-type" content="text/html;charset=utf-8"/>
        <meta name="Author" content="Sean Hunter"/>
        <meta name="MSSmartTagsPreventParsing" content="TRUE"/>
        <meta name="description" content="Starting to learn how to make ocaml programs that are not just toys, and extending the derivatives pricer further"/>
		<link rel="stylesheet" type="text/css" href="/web/20160512184058cs_/http://www.uncarved.com/static/style.css"/>
        <link rel="self" type="text/html" href="http://www.uncarved.com/articles/practical_ocaml"/>
        <title>The Uncarved Blog: Using Ocaml in Practice</title>
	</head>

	<body>
		<div id="left_menu">
			<ul>
                <li><a href="https://web.archive.org/web/20160512184058/http://www.uncarved.com/articles/practical_ocaml">permalink</a></li>
                <li><a href="https://web.archive.org/web/20160512184058/http://www.uncarved.com/">top</a></li>
                
				<li><a href="/web/20160512184058/http://www.uncarved.com/articles/contact">contact me</a></li>
				<li><a href="/web/20160512184058/http://www.uncarved.com/login/" rel="nofollow">not logged in</a></li>
                
			</ul>
		</div>
		<div class="body">
            
			<h2>
                
                Using Ocaml in Practice
			</h2>
            

            
            <div class="precis">Starting to learn how to make ocaml programs that are not just toys, and extending the derivatives pricer further</div>
            

            <p>My experience learning ocaml has been pretty enjoyable so far.  A friend told me about Jason Hickey's pdf book <a href="https://web.archive.org/web/20160512184058/http://www.cs.caltech.edu/courses/cs134/cs134b/book.pdf">Introduction to the Objective Caml Programming Language</a> which is commendably brief and has really helped as I go on to try ocaml further.  The second thing that has helped is that I have discovered <a href="https://web.archive.org/web/20160512184058/http://utopia.knoware.nl/~hlub/uck/rlwrap/">rlwrap</a>, so the toploop is no longer such an unfriendly place to be.</p>
<p>Furthermore, I have split the pricer that I <a href="https://web.archive.org/web/20160512184058/http://www.uncarved.com/blog/ocaml_deriv_1.mrk">began</a> developing yesterday into a number of files and build them into a single executable using <code>ocamlc</code>. First, <code>gaussian.ml</code>, containing the random number functions:</p>
<pre><code>open Random;;

(* initialize the random number generator *)
Random.self_init;;

(* get a random gaussian using a Box-Muller transform, described
 * here http://en.wikipedia.org/wiki/Box-Muller_transform *)
let rec get_one_gaussian_by_box_muller () =
    (* Generate two uniform numbers from -1 to 1 *)
    let x = Random.float 2.0 -. 1.0 in
    let y = Random.float 2.0 -. 1.0 in
    let s = x*.x +. y*.y in
    if s &gt; 1.0 then get_one_gaussian_by_box_muller ()
    else x *. sqrt (-2.0 *. (log s) /. s)
    ;;

(* get a gaussian through oversampling and subtraction *)
let get_one_gaussian_by_summation () =
    let rec add_one limit count so_far =
        if count==limit then so_far
        else add_one limit (count+1) (so_far +. (Random.float 1.0)) in
    (add_one 12 0 0.0) -. 6.0
    ;;

let get_one_gaussian = get_one_gaussian_by_box_muller
</code></pre>
<p>I added the summation method because when I first tried the pricer on real data the numbers were hopeless (now they are just somewhat out of line with market observables), and I suspected a bug in my random numbers.  I was correct, I did have incorrect random numbers.</p>
<p>Then I have <code>payoff.ml</code>, containing my payoff functions.  I have added a few more simple payoffs, and moved to named function arguments:</p>
<pre><code>(** a vanilla option pays off the difference between the spot price
 ** and the strike, or expires worthless *)
let call ~strike ~spot = max (spot -. strike) 0.0;;
let put ~strike ~spot = max (strike -. spot) 0.0;;

let digital payoff = if payoff&gt; 0.0 then 1.0 else 0.0;;
let digital_call ~strike ~spot = digital (call ~strike:strike ~spot:spot);;
let digital_put ~strike ~spot = digital (put ~strike:strike ~spot:spot);;

(** A double digital pays 1 if spot is between two barriers, zero
 ** otherwise *)
let double_digital ~low ~high ~spot =
    assert (low &lt; high);
    if (low &lt;= spot &amp;&amp; spot &lt;= high) then 1.0
    else 0.0;;
</code></pre>
<p><code>mc1c.ml</code> contains the actual Monte Carlo simulator, and it is unchanged except to use named function arguments, and to qualify the name of the get_one_gaussian function, which is now in a seperate file:</p>
<pre><code>(* Price an option with a flexible payoff using Monte Carlo. *)
let sim ~payoff ~expiry ~spot ~vol ~r ~num_paths =
    let variance = vol *. vol *. expiry in
    let root_variance = sqrt variance in
    let ito_correction = -0.5 *. variance in
    let moved_spot = spot *. exp (r *. expiry +. ito_correction) in
    let rec do_path i running_sum =
        if i &lt; num_paths then begin
            let this_gaussian = Gaussian.get_one_gaussian () in
            let this_spot = moved_spot *. (exp (root_variance *. this_gaussian)) in
            let this_payoff = payoff ~spot:this_spot in
            do_path (i+1) (running_sum +. this_payoff)
        end
        else (running_sum /. (float_of_int num_paths)) *. (exp (-1.0 *. r *. expiry))
    in
    do_path 0 0.0
    ;;
</code></pre>
<p>Finally I have my test file which runs the test cases.  Now that I use named function args I can partially-apply function args in any order, so I make a test harness that sets up a particular marketdata scenario and runs the pricer:</p>
<pre><code>let print_mc ?(num_paths=100000) label payoff =
    let mc payoff =
        Mc1c.sim
            ~payoff:payoff
            ~expiry:0.2
            ~spot:161.3
            ~vol:0.35
            ~r:0.045
            ~num_paths:num_paths
         in
    Printf.printf "%s: %f\n" label (mc payoff)
;;

print_mc "call" (Payoff.call ~strike:160.0);;
print_mc "digital call" (Payoff.digital_call ~strike:160.0);;
print_mc "put" (Payoff.put ~strike:170.0);;
print_mc "digital put" (Payoff.digital_put ~strike:170.0);;
print_mc "double digital" (Payoff.double_digital ~low:160.0 ~high:170.0) ~num_paths:250000;;

(* price one option, test the payoff against a target price and 
 * print the result  *)
let test_mc ?(num_paths=1000) ?(expiry=1.0) ?(r=0.0) label payoff target =
    let mc payoff =
        Mc1c.sim
            ~payoff:payoff
            ~expiry:expiry
            ~spot:161.3
            ~vol:0.35
            ~r:r
            ~num_paths:num_paths
         in
    let price = mc payoff in
    let tolerance = 0.00001 in
    Printf.printf "Test %s - price: %f target: %f\n" label price target;
    assert( abs_float(price-.target) &lt; tolerance )
;;

test_mc "Spot to one" (fun ~spot-&gt;1.0) 1.0;;
test_mc "Spot to zero" (fun ~spot-&gt;0.0) 0.0;;
let r = 0.05 in
let npv =  exp(-1.0 *. r) in
    test_mc "Spot to one with rates" (fun ~spot-&gt;1.0) npv ~r:r;;

(* vim: set sw=4 ts=4 expandtab: *)
</code></pre>
<p>This is pretty cool.  As you can see, I made the number of mc paths an optional parameter.  I have added a few assertions that trivial payoff functions price correctly and that discounting works.</p>
<p>Now I build an object from each ml file using ocamlc and then compile them all to a built object at the end.  You need to be careful to do them all in the correct order where you have functions defined in one file, called in another, as we have here.</p>
		<hr/>
        <p class="footer">
        
        <span id="tags">Tags:
            
            <a href="https://web.archive.org/web/20160512184058/http://www.uncarved.com/tags/computers">computers</a>
            
        </span>
        
        Last modified: 2007-06-13T06:41:39Z</p>
        <p class="tagline">Unless otherwise specified the contents of this page are copyright &copy; 2015 <a href="https://web.archive.org/web/20160512184058/mailto:sean@uncarved.com">Sean Hunter</a>.  This work is licensed under a Creative Commons Attribution-ShareAlike 4.0 International <a rel="license" href="https://web.archive.org/web/20160512184058/http://creativecommons.org/licenses/by-sa/4.0/">License</a>.
        <!-- figure out metadata -->
	</p>
		</div>
    </body>
</html><!--
     FILE ARCHIVED ON 18:40:58 May 12, 2016 AND RETRIEVED FROM THE
     INTERNET ARCHIVE ON 06:59:35 Jul 30, 2020.
     JAVASCRIPT APPENDED BY WAYBACK MACHINE, COPYRIGHT INTERNET ARCHIVE.

     ALL OTHER CONTENT MAY ALSO BE PROTECTED BY COPYRIGHT (17 U.S.C.
     SECTION 108(a)(3)).
-->
<!--
playback timings (ms):
  esindex: 0.01
  LoadShardBlock: 108.262 (3)
  exclusion.robots.policy: 0.137
  captures_list: 132.666
  exclusion.robots: 0.146
  PetaboxLoader3.resolve: 26.522
  load_resource: 37.763
  PetaboxLoader3.datanode: 114.332 (4)
  RedisCDXSource: 1.797
  CDXLines.iter: 19.568 (3)
-->