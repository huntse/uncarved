<!DOCTYPE html
PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
    <!-- turn this into html5 -->
    <head><script src="//archive.org/includes/analytics.js?v=cf34f82" type="text/javascript"></script>
<script type="text/javascript">window.addEventListener('DOMContentLoaded',function(){var v=archive_analytics.values;v.service='wb';v.server_name='wwwb-app41.us.archive.org';v.server_ms=201;archive_analytics.send_pageview({});});</script><script type="text/javascript" src="/_static/js/playback.bundle.js?v=R56vIgLu" charset="utf-8"></script>
<script type="text/javascript" src="/_static/js/wombat.js?v=cRqOKCOw" charset="utf-8"></script>
<script type="text/javascript">
if (window._WBWombatInit) {
  wbinfo = {}
  wbinfo.url = "http://www.uncarved.com/articles/ocaml_deriv_2";
  wbinfo.timestamp = "20160512183041";
  wbinfo.request_ts = "20160512183041";
  wbinfo.prefix = "https://web.archive.org/web/";
  wbinfo.mod = "if_";
  wbinfo.is_framed = false;
  wbinfo.is_live = false;
  wbinfo.coll = "web";
  wbinfo.proxy_magic = "";
  wbinfo.static_prefix = "/_static/";
  wbinfo.enable_auto_fetch = true;
  wbinfo.auto_fetch_worker_prefix = "https://web.archive.org/web/";
  wbinfo.wombat_ts = "20160512183041";
  wbinfo.wombat_sec = "1463077841";
  wbinfo.wombat_scheme = "https";
  wbinfo.wombat_host = "www.uncarved.com";
  wbinfo.ignore_prefixes = ["/__wb/",
                            "/_static/",
                            "/web/",
                            "http://analytics.archive.org/",
                            "https://analytics.archive.org/",
                            "//analytics.archive.org/",
                            "http://archive.org/",
                            "https://archive.org/",
                            "//archive.org/",
                            "http://faq.web.archive.org/",
                            "http://web.archive.org/",
                            "https://web.archive.org/"
                            ];
  wbinfo.wombat_opts = {};
  window._WBWombatInit(wbinfo);
}
__wm.init("https://web.archive.org/web");
</script>
<link rel="stylesheet" type="text/css" href="/_static/css/banner-styles.css?v=_99BHQfY" />
<link rel="stylesheet" type="text/css" href="/_static/css/iconochive.css?v=qtvMKcIJ" />
<!-- End Wayback Rewrite JS Include -->

        <meta http-equiv="content-type" content="text/html;charset=utf-8"/>
        <meta name="Author" content="Sean Hunter"/>
        <meta name="MSSmartTagsPreventParsing" content="TRUE"/>
        <meta name="description" content="Extending the basic mc pricer to handle different payoffs, we see how partial function application works"/>
		<link rel="stylesheet" type="text/css" href="/web/20160512183041cs_/http://www.uncarved.com/static/style.css"/>
        <link rel="self" type="text/html" href="http://www.uncarved.com/articles/ocaml_deriv_2"/>
        <title>The Uncarved Blog: Derivatives pricing in ocaml Part 2</title>
	</head>

	<body>
		<div id="left_menu">
			<ul>
                <li><a href="https://web.archive.org/web/20160512183041/http://www.uncarved.com/articles/ocaml_deriv_2">permalink</a></li>
                <li><a href="https://web.archive.org/web/20160512183041/http://www.uncarved.com/">top</a></li>
                
				<li><a href="/web/20160512183041/http://www.uncarved.com/articles/contact">contact me</a></li>
				<li><a href="/web/20160512183041/http://www.uncarved.com/login/" rel="nofollow">not logged in</a></li>
                
			</ul>
		</div>
		<div class="body">
            
			<h2>
                
                Derivatives pricing in ocaml Part 2
			</h2>
            

            
            <div class="precis">Extending the basic mc pricer to handle different payoffs, we see how partial function application works</div>
            

            <p>This is the third article in a series on using functional programming for financial applications which started <a href="https://web.archive.org/web/20160512183041/http://www.uncarved.com/blog/ocaml_finance.mrk">here</a>.</p>
<p>So given our <a href="https://web.archive.org/web/20160512183041/http://www.uncarved.com/blog/ocaml_deriv_1.mrk">first</a> Monte Carlo simulator, and the <a href="https://web.archive.org/web/20160512183041/http://www.uncarved.com/blog/ocaml_finance.mrk">payoff functions</a> that we started with, it's easy to see how we extend the pricer to handle Joshi's first question at the end of chapter 1 (to price puts):</p>
<pre><code>(* mc1b.ml - A rudimentary option pricer to answer the exercises at the
 * end of chapter 1 in Joshi.
 *
 * Written by Sean Hunter &lt;sean@uncarved.com&gt;
 *
 * This is demonstration code only.  You are free to use it under the
 * terms of the Creative Commons Attribution 2.5 license, but don't
 * expect it to accurately price real options.
 *)
open Random;;
open Printf;;

(* initialize the random number generator *)
Random.self_init;;

(* get a random gaussian using a Box-Muller transform, described
 * here http://en.wikipedia.org/wiki/Box-Muller_transform *)
let rec get_one_gaussian_by_box_muller () =
    (* Generate two uniform numbers from -1 to 1 *)
    let x = Random.float 2.0 -. 1.0 in
    let y = Random.float 2.0 -. 1.0 in
    let s = x*.x +. y*.y in
    if s &gt; 1.0 then get_one_gaussian_by_box_muller ()
    else x *. sqrt (-2.0 *. (log s) /. s)
    ;;

 (* a vanilla option pays off the difference between the spot price
 * and the strike, or expires worthless *)
let put_payoff strike spot =
    max ( strike -. spot ) 0.0;;

let call_payoff strike spot =
    max (spot -. strike ) 0.0;;

(* Price an option with a flexible payoff using Monte Carlo. *)
let simple_monte_carlo_1a payoff expiry strike spot vol r num_paths =
    let variance = vol *. vol *. expiry in
    let root_variance = sqrt variance in
    let ito_correction = -0.5 *. variance in
    let moved_spot = spot *. exp (r *. expiry +. ito_correction) in
    let rec do_path i running_sum =
        if i &lt; num_paths then begin
            let this_gaussian = get_one_gaussian_by_box_muller () in
            let this_spot = moved_spot *. (exp (root_variance *. this_gaussian)) in
            let this_payoff = payoff strike this_spot in
            do_path (i+1) (running_sum +. this_payoff)
        end
        else (running_sum /. (float_of_int num_paths)) *. (exp (-1.0 *. r *. expiry))
    in
    do_path 0 0.0
    ;;

(* price one put and one call option struck at the money *)    
printf "%f\n" (simple_monte_carlo_1a call_payoff 0.025 195.5 195.5 0.20 0.045 100000);;
printf "%f\n" (simple_monte_carlo_1a put_payoff 0.025 195.5 195.5 0.20 0.045 100000);;
</code></pre>
<p>So we pass a payoff function into the Monte Carlo simulator and call that function for each path.  This isn't quite general enough to handle double digitals though.  A double digital is an option that pays 1 if the spot is between two barrier prices at expiry and zero otherwise.  However, the payoff function here has to take the strike and the spot.  This is where one of the great features of functional programming comes in: partial function application.  In ocaml, if you call a function that takes 2 parameters, but give it only one, the return type is a function that takes one parameter.  Amazingly partial function application is just there by default and there's no need for tedious binders like there are in the STL in C++ for example.  This will explain:</p>
<pre><code>% ocaml                                                                                                                          
    Objective Caml version 3.09.3

# let myadd x y=x+y;;
val myadd : int -&gt; int -&gt; int = &lt;fun&gt;
# let add2=myadd 2;;
val add2 : int -&gt; int = &lt;fun&gt;
# add2 5;;
- : int = 7
# add2 16;;
- : int = 18
</code></pre>
<p>So <code>myadd</code> adds two numbers, and by calling it with just one (a 2) we create a function that takes one argument and adds two to it.  This is exactly what we need for our flexible payoff function.  You can think of the partially applied function args as being all the things that are constant on the termsheet of the trade.  Our payoff functions remain the same, except we add one for double digitals:</p>
<pre><code>let double_digital_payoff low high spot =
        if (low &lt;= spot &amp;&amp; spot &lt;= high) then 1.0
        else 0.0;;
</code></pre>
<p>...and we change the mc pricer to just call the payoff func with the spot on the current mc path.  We will partially-apply any other arguments the payoff functions need when we invoke the pricer:</p>
<pre><code>(* Price an option with a flexible payoff using Monte Carlo. *)
let simple_monte_carlo_1b payoff expiry spot vol r num_paths =
    let variance = vol *. vol *. expiry in
    let root_variance = sqrt variance in
    let ito_correction = -0.5 *. variance in
    let moved_spot = spot *. exp (r *. expiry +. ito_correction) in
    let rec do_path i running_sum =
        if i &lt; num_paths then begin
            let this_gaussian = get_one_gaussian_by_box_muller () in
            let this_spot = moved_spot *. (exp (root_variance *. this_gaussian)) in
            let this_payoff = payoff this_spot in
            do_path (i+1) (running_sum +. this_payoff)
        end
        else (running_sum /. (float_of_int num_paths)) *. (exp (-1.0 *. r *. expiry))
    in
    do_path 0 0.0
    ;;
</code></pre>
<p>Now see how we call this pricer.  It's simplicity itself:</p>
<pre><code>printf "%f\n" (simple_monte_carlo_1b (call_payoff 160.0) 0.2 161.3 0.35 0.045 250000);;
printf "%f\n" (simple_monte_carlo_1b (put_payoff 170.0) 0.2 161.3 0.31 0.045 250000);;
printf "%f\n" (simple_monte_carlo_1b (double_digital_payoff 160.0 170.0) 0.2 161.3 0.29 0.045 250000);;
</code></pre>
<p>I find this immensely pleasing.  I have hardly started learning the language, and yet generalising this code was simplicity itself due to features in the language.  Partial function application is available in imperative languages (C++ notably uses it to provide predicates and adaptable functions in the STL), but there is a lot of nasty additional syntax.  The way it works so seemlessly in ocaml is terrific.  </p>
<p>Its worth coming back to earth a little bit with the observation that the prices that I am seeing from this thing right now don't match those I can observe in the market so I am sure there is some debugging yet to do.  I would also like to make the code into a few modules, but I am not sure how you do that in ocaml yet.</p>
		<hr/>
        <p class="footer">
        
        <span id="tags">Tags:
            
            <a href="https://web.archive.org/web/20160512183041/http://www.uncarved.com/tags/computers">computers</a>
            
        </span>
        
        Last modified: 2007-06-06T08:58:44Z</p>
        <p class="tagline">Unless otherwise specified the contents of this page are copyright &copy; 2015 <a href="https://web.archive.org/web/20160512183041/mailto:sean@uncarved.com">Sean Hunter</a>.  This work is licensed under a Creative Commons Attribution-ShareAlike 4.0 International <a rel="license" href="https://web.archive.org/web/20160512183041/http://creativecommons.org/licenses/by-sa/4.0/">License</a>.
        <!-- figure out metadata -->
	</p>
		</div>
    </body>
</html><!--
     FILE ARCHIVED ON 18:30:41 May 12, 2016 AND RETRIEVED FROM THE
     INTERNET ARCHIVE ON 07:00:13 Jul 30, 2020.
     JAVASCRIPT APPENDED BY WAYBACK MACHINE, COPYRIGHT INTERNET ARCHIVE.

     ALL OTHER CONTENT MAY ALSO BE PROTECTED BY COPYRIGHT (17 U.S.C.
     SECTION 108(a)(3)).
-->
<!--
playback timings (ms):
  exclusion.robots: 0.28
  PetaboxLoader3.resolve: 104.759 (3)
  LoadShardBlock: 112.742 (3)
  esindex: 0.018
  exclusion.robots.policy: 0.266
  captures_list: 136.779
  RedisCDXSource: 0.883
  load_resource: 57.341
  PetaboxLoader3.datanode: 58.054 (4)
  CDXLines.iter: 19.372 (3)
-->