<!DOCTYPE html
PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
    <!-- turn this into html5 -->
    <head><script src="//archive.org/includes/analytics.js?v=cf34f82" type="text/javascript"></script>
<script type="text/javascript">window.addEventListener('DOMContentLoaded',function(){var v=archive_analytics.values;v.service='wb';v.server_name='wwwb-app12.us.archive.org';v.server_ms=186;archive_analytics.send_pageview({});});</script><script type="text/javascript" src="/_static/js/playback.bundle.js?v=R56vIgLu" charset="utf-8"></script>
<script type="text/javascript" src="/_static/js/wombat.js?v=cRqOKCOw" charset="utf-8"></script>
<script type="text/javascript">
if (window._WBWombatInit) {
  wbinfo = {}
  wbinfo.url = "http://www.uncarved.com/articles/ocaml_classes_2";
  wbinfo.timestamp = "20160512183159";
  wbinfo.request_ts = "20160512183159";
  wbinfo.prefix = "https://web.archive.org/web/";
  wbinfo.mod = "if_";
  wbinfo.is_framed = false;
  wbinfo.is_live = false;
  wbinfo.coll = "web";
  wbinfo.proxy_magic = "";
  wbinfo.static_prefix = "/_static/";
  wbinfo.enable_auto_fetch = true;
  wbinfo.auto_fetch_worker_prefix = "https://web.archive.org/web/";
  wbinfo.wombat_ts = "20160512183159";
  wbinfo.wombat_sec = "1463077919";
  wbinfo.wombat_scheme = "https";
  wbinfo.wombat_host = "www.uncarved.com";
  wbinfo.ignore_prefixes = ["/__wb/",
                            "/_static/",
                            "/web/",
                            "http://analytics.archive.org/",
                            "https://analytics.archive.org/",
                            "//analytics.archive.org/",
                            "http://archive.org/",
                            "https://archive.org/",
                            "//archive.org/",
                            "http://faq.web.archive.org/",
                            "http://web.archive.org/",
                            "https://web.archive.org/"
                            ];
  wbinfo.wombat_opts = {};
  window._WBWombatInit(wbinfo);
}
__wm.init("https://web.archive.org/web");
</script>
<link rel="stylesheet" type="text/css" href="/_static/css/banner-styles.css?v=_99BHQfY" />
<link rel="stylesheet" type="text/css" href="/_static/css/iconochive.css?v=qtvMKcIJ" />
<!-- End Wayback Rewrite JS Include -->

        <meta http-equiv="content-type" content="text/html;charset=utf-8"/>
        <meta name="Author" content="Sean Hunter"/>
        <meta name="MSSmartTagsPreventParsing" content="TRUE"/>
        <meta name="description" content="Parameter objects make more sense when we pass piecewise functions to the pricer - <p>Unfortunately the class for constant parameters that we developed ..."/>
		<link rel="stylesheet" type="text/css" href="/web/20160512183159cs_/http://www.uncarved.com/static/style.css"/>
        <link rel="self" type="text/html" href="http://www.uncarved.com/articles/ocaml_classes_2"/>
        <title>The Uncarved Blog: Ocaml objects part 2</title>
	</head>

	<body>
		<div id="left_menu">
			<ul>
                <li><a href="https://web.archive.org/web/20160512183159/http://www.uncarved.com/articles/ocaml_classes_2">permalink</a></li>
                <li><a href="https://web.archive.org/web/20160512183159/http://www.uncarved.com/">top</a></li>
                
				<li><a href="/web/20160512183159/http://www.uncarved.com/articles/contact">contact me</a></li>
				<li><a href="/web/20160512183159/http://www.uncarved.com/login/" rel="nofollow">not logged in</a></li>
                
			</ul>
		</div>
		<div class="body">
            
			<h2>
                
                Ocaml objects part 2
			</h2>
            

            
            <div class="precis">Parameter objects make more sense when we pass piecewise functions to the pricer</div>
            

            <p>Unfortunately the class for constant parameters that we developed <a href="https://web.archive.org/web/20160512183159/http://www.uncarved.com/blog/ocaml_classes.mrk">before</a> is just not that useful.  We would be better off just using a float if that was all we wanted.  The advantage is, however, that we have defined the interface we need for these functions, and what we need is something that can return us the integral of a function and the integral of the square of a function in an interval:</p>
<pre><code>   method integral :       float -&gt; float -&gt; float
   method integral_sq :    float -&gt; float -&gt; float
</code></pre>
<p>If we can do that, we can use our function in the mc pricer, so let's define a 'parameters' class for linear functions.  This will take
two coefficients a and b and our parameter will model the function f(x) = ax + b . The integral of f(x) dx is ax^2 + bx because we're trying to find the area
under a triangle for the first term and a rectangle for the second.  I needed a
little help with f(x)^2 dx (thanks Iain!), but here it is:</p>
<pre><code>(** Parameter class that models a linear function f(x) -&gt; ax + b *)
class parameter_linear' a b =
object(self)
    inherit parameter
    method integral t1 t2 =
      let integrate_to x = 0.5 *. x *. a *. x +. x *. b in
        integrate_to t2 -. integrate_to t1
    method integral_sq t1 t2 =
        a ** 2.0 *. (t2 ** 3.0 -. t1 ** 3.0) +.
        a *. b *. (t2 ** 2.0 -. t1 ** 1.0) +.
        b ** 2.0 *. (t2 -. t1)
end;;

class parameter_linear a b = (parameter_linear' a b : parameter_type);;
</code></pre>
<p>This works fine, but what we really want is <a href="https://web.archive.org/web/20160512183159/http://mathforum.org/library/drmath/sets/select/dm_piecewise.html">piecewise functions</a> and
piecewise constants.  These give us the ability to have parameters that we can
calibrate to observable data:</p>
<pre><code>(** For piecewise constants and piecewise linear functions a "piece" is a
* parameter that applies between low and high limits. *)
type piece = Piece of float * float * parameter_type;;
</code></pre>
<p>This is what we are going to use to make the pieces of our piecewise functions-
a tuple of low and high limits, and a parameter object that can give us the
integrals in these limits.  Integrating the piecewise function then becomes
walking the list of pieces and integrating everything that is in the region we
are interested in.</p>
<pre><code>(** Class for piecewise parameters.  Takes a list of pieces which each
* specify the limits and the linear or const parameter in each region. 
*
* At present, does no checking that the pieces are continuous and not
* overlapping *)
class parameter_piecewise' pieces =
  (* there's probably a better way of doing this, but anyway...
   * Apply a function to each piece, with the parameters being the part of
   * the interval from t1 to t2 that is inside the interval of the piece *)
  let visit_pieces pieces fn t1 t2 = 
      let visit_piece piece low high =
        if (low &gt; t2 || high &lt; t1) then
          0.0
        else 
            let range_start = max t1 low in
            let range_end = min t2 high in
            (fn piece) range_start range_end in
      let rec visit_list so_far lis =
        match lis with
            [] -&gt; so_far (** we're done *)
          | Piece(low, high, p) :: rest -&gt; visit_list (so_far +. (visit_piece p low high)) rest
      in  
        visit_list 0.0 pieces
  in         
object(self)
    inherit parameter
    method integral t1 t2 = visit_pieces pieces (fun x-&gt;x#integral) t1 t2
    method integral_sq t1 t2 = visit_pieces pieces (fun x-&gt;x#integral_sq) t1 t2
end;;

(** Piecewise parameters class with implementation hidden *)
class parameter_piecewise x = (parameter_piecewise' x : parameter_type);;
</code></pre>
<p>As you can see, I have a local visitor function which walks the list of pieces
and calls the right method on each one.  I do this using a nifty little
tail-recursive pattern-matcher.  This works but I am a bit dissatisfied with
the way I have to trick visit_pieces into calling the integral or integral_sq
methods.  There is a better way I'm sure- I just don't know what it is yet.</p>
<p>I could leave this implementation and it would be functionally-complete, but it would be a bit of a pain to build the piecewise functions, so I make a couple of little helper functions:</p>
<pre><code>(** helper funcs to make parts of a piecewise function *)
let make_const_piece low high x = Piece(low, high, new parameter_const x);;
let make_linear_piece low high a b = Piece(low, high, new parameter_linear a b);;
</code></pre>
<p>They're still not ideal- I would like to give a list of 2-tuples specifying the upper bound and a point for each piece, and have the function return the piecewise function or constant that "join the dots", but anyway this gives us the ability to make lists of pieces by doing this sort of thing:</p>
<pre><code>(* price one option and print the result  *)
let print_mc ?(num_paths=100000) label payoff =
    let pieces = [
        Param.make_const_piece 0.0 0.25 0.35;
        Param.make_const_piece 0.25 1.0 0.25;
    ] in
    let vol=new Param.parameter_piecewise pieces in
    let mc payoff =
        Mc.sim
            ~payoff:payoff
            ~expiry:0.25
            ~spot:1.613
            ~vol:vol 
            ~r:(new Param.parameter_const 0.055)
            ~num_paths:num_paths
         in
    Printf.printf "%s: %f\n" label (mc payoff)
;;
</code></pre>
<p>Note that our piecewise const parameter doesn't require the function to be continuous.  Given this vol function, we can price as before.</p>
		<hr/>
        <p class="footer">
        
        <span id="tags">Tags:
            
            <a href="https://web.archive.org/web/20160512183159/http://www.uncarved.com/tags/computers">computers</a>
            
        </span>
        
        Last modified: 2007-06-21T06:30:35Z</p>
        <p class="tagline">Unless otherwise specified the contents of this page are copyright &copy; 2015 <a href="https://web.archive.org/web/20160512183159/mailto:sean@uncarved.com">Sean Hunter</a>.  This work is licensed under a Creative Commons Attribution-ShareAlike 4.0 International <a rel="license" href="https://web.archive.org/web/20160512183159/http://creativecommons.org/licenses/by-sa/4.0/">License</a>.
        <!-- figure out metadata -->
	</p>
		</div>
    </body>
</html><!--
     FILE ARCHIVED ON 18:31:59 May 12, 2016 AND RETRIEVED FROM THE
     INTERNET ARCHIVE ON 06:59:00 Jul 30, 2020.
     JAVASCRIPT APPENDED BY WAYBACK MACHINE, COPYRIGHT INTERNET ARCHIVE.

     ALL OTHER CONTENT MAY ALSO BE PROTECTED BY COPYRIGHT (17 U.S.C.
     SECTION 108(a)(3)).
-->
<!--
playback timings (ms):
  esindex: 0.014
  exclusion.robots: 0.135
  PetaboxLoader3.datanode: 46.642 (4)
  load_resource: 55.66
  PetaboxLoader3.resolve: 27.509
  captures_list: 123.88
  exclusion.robots.policy: 0.124
  CDXLines.iter: 21.45 (3)
  LoadShardBlock: 47.443 (3)
  RedisCDXSource: 50.47
-->